C51 COMPILER V9.52.0.0   MAIN                                                              12/20/2019 16:20:47 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /**********************************************************
   2           * 实验名称：思修SX-GPIO-KB模块测试实验（PAC9698）
   3           * 淘宝店铺：思修电子工作室
   4           * 店铺地址：https://520mcu.taobao.com/
   5           * 芯片型号：STC89C52RC
   6           * 时钟说明：芯片外部11.0592MHz
   7           * 接线说明：P3^7接到SX-GPIO-KB模块SDA引脚
   8                       P3^6接到SX-GPIO-KB模块SCL引脚
   9           * 模块地址：A0=0，A1=0，A2=0，OE=0（模块背面短接焊盘已配置）
  10           * 测试现象：连接A、B、C、D、E端口的40个LED灯同时闪烁
  11          ***********************************************************/            
  12          #include <reg52.h> //头文件的包含       
  13          #include <intrins.h>
  14          /********************常用数据类型定义**********************/
  15          #define u8  uint8_t
  16          #define u16 uint16_t
  17          #define u32 uint32_t
  18          typedef unsigned char  uint8_t;
  19          typedef unsigned int   uint16_t;
  20          typedef unsigned long  uint32_t;
  21          /*************************宏定义***************************/
  22          #define  _Nop()  _nop_()   //定义空指令
  23          #define PCA9698 0x40       //PCA9698地址 
  24          /*******************端口/引脚定义区域**********************/
  25          sbit SDA=P3^7;            //模拟I2C数据传送位
  26          sbit SCL=P3^6;            //模拟I2C时钟控制位
  27          bit ack;                  //应答标志位
  28          /*********************函数声明区域*************************/
  29          void Delay_Ms(u16 ms);    //毫秒延迟函数
  30          void Start_I2c(void);     //IIC起动总线函数
  31          void Stop_I2c(void);      //IIC结束总线函数
  32          void SendByte(u8 c);      //IIC字节发送函数
  33          u8 RcvByte(void);         //IIC字节接收函数
  34          void Ack_I2c(bit a);      //IIC应答函数
  35          bit ISendByte(u8 sla,u8 c);//向无子地址器件发送字节数据函数
  36          bit ISendStr(u8 sla,u8 suba,u8 *s,u8 no);
  37          //向有子地址器件发送多字节数据函数
  38          bit IRcvByte(u8 sla,u8 *c);//向无子地址器件读字节数据函数
  39          bit IRcvStr(u8 sla,u8 suba,u8 *s,u8 no);
  40          //向有子地址器件接收多字节数据函数
  41          //*********************主函数区域**************************/
  42          void main(void)
  43          {
  44   1        u8 All_ctrl[1]={0x80};
  45   1        //设置全组控制寄存器数组（这里为默认值）
  46   1        u8 Select_Mode[1]={0x12};
  47   1        //设置模式选择寄存器（这里配置为应答时输出改变 使能中断响应）
  48   1        u8 GPIO_H[1]={0xff};
  49   1        //设置I/O端口状态数组
  50   1        u8 GPIO_L[1]={0x00};
  51   1        //设置I/O端口状态数组
  52   1        //u8 In_array[1]={0x7f};
  53   1        //设置I/O某端口号为中断标志位
  54   1        Delay_Ms(10);
  55   1        ISendStr(PCA9698,0X2A,Select_Mode,1);
C51 COMPILER V9.52.0.0   MAIN                                                              12/20/2019 16:20:47 PAGE 2   

  56   1        //配置模式选择寄存器地址0x2A
  57   1        ISendStr(PCA9698,0X29,All_ctrl,1);
  58   1        //配置全组控制寄存器地址0X29
  59   1        ISendStr(PCA9698,0X28,GPIO_H,1);
  60   1        //配置输出结构寄存器地址0X28(写入1为默认推挽，0为开漏)，这里配置为推挽
  61   1        //ISendStr(PCA9698,0X23,In_array,1);
  62   1        //0X23为中断屏蔽地址寄存器,配置为使用PD8作为中断标志位
  63   1        //当PD8端口状态改变时中断发生,中断输出引脚In变低电平
  64   1        //配置I/0口寄存器(设置为输出/输入，A~D组地址为0X18~0X1C)
  65   1        ISendStr(PCA9698,0X18,GPIO_L,1);//配置A组I/O为输出 
  66   1        ISendStr(PCA9698,0X19,GPIO_L,1);//配置B组I/O为输出
  67   1        ISendStr(PCA9698,0X1A,GPIO_L,1);//配置C组I/O为输出
  68   1        ISendStr(PCA9698,0X1B,GPIO_L,1);//配置D组I/O为输出
  69   1        ISendStr(PCA9698,0X1C,GPIO_L,1);//配置E组I/O为输出
  70   1        while(1)
  71   1        {
  72   2          //配置输出端口寄存器(设置输出相应的状态，A~E组端口的地址为0X08~0X0C） 
  73   2          Delay_Ms(100);
  74   2          ISendStr(PCA9698,0X08,GPIO_L,1);//A推挽输出高电平
  75   2          ISendStr(PCA9698,0X09,GPIO_L,1);//B推挽输出高电平
  76   2          ISendStr(PCA9698,0X0a,GPIO_L,1);//C推挽输出高电平
  77   2          ISendStr(PCA9698,0X0b,GPIO_L,1);//D推挽输出高电平
  78   2          ISendStr(PCA9698,0X0c,GPIO_L,1);//E推挽输出高电平
  79   2          Delay_Ms(100);//延迟闪烁
  80   2          ISendStr(PCA9698,0X08,GPIO_H,1);//A推挽输出低电平
  81   2          ISendStr(PCA9698,0X09,GPIO_H,1);//B推挽输出低电平
  82   2          ISendStr(PCA9698,0X0a,GPIO_H,1);//C推挽输出低电平
  83   2          ISendStr(PCA9698,0X0b,GPIO_H,1);//D推挽输出低电平
  84   2          ISendStr(PCA9698,0X0C,GPIO_H,1);//E推挽输出低电平
  85   2        }
  86   1      }
  87          //***************************************************************/
  88          //起动总线函数Start_I2c(void)，无形参,无返回值
  89          //***************************************************************/
  90          void Start_I2c(void)
  91          {
  92   1        SDA=1;    //发送起始条件的数据信号
  93   1        _Nop();
  94   1        SCL=1;
  95   1        _Nop();   //起始条件建立时间大于4.7us,延时
  96   1        _Nop();
  97   1        _Nop();
  98   1        _Nop();
  99   1        _Nop();    
 100   1        SDA=0;    //发送起始信号
 101   1        _Nop();   //起始条件锁定时间大于4μs
 102   1        _Nop();
 103   1        _Nop();
 104   1        _Nop();
 105   1        _Nop();       
 106   1        SCL=0;   //钳住I2C总线，准备发送或接收数据 
 107   1        _Nop();
 108   1        _Nop();
 109   1      }   
 110          //***************************************************************/
 111          //结束总线函数 Stop_I2c(void)，无形参,无返回值
 112          //***************************************************************/
 113          void Stop_I2c(void)
 114          {
 115   1        SDA=0;   //发送结束条件的数据信号
 116   1        _Nop();  //发送结束条件的时钟信号
 117   1        SCL=1;   //结束条件建立时间大于4μs
C51 COMPILER V9.52.0.0   MAIN                                                              12/20/2019 16:20:47 PAGE 3   

 118   1        _Nop();
 119   1        _Nop();
 120   1        _Nop();
 121   1        _Nop();
 122   1        _Nop();
 123   1        SDA=1;   //发送I2C总线结束信号
 124   1        _Nop();
 125   1        _Nop();
 126   1        _Nop();
 127   1        _Nop();
 128   1      }
 129          //***************************************************************/
 130          //IIC字节数据传送函数SendByte(u8 c)，有形参c,无返回值
 131          //***************************************************************/
 132          void  SendByte(u8 c)
 133          {
 134   1        u8 BitCnt;
 135   1        for(BitCnt=0;BitCnt<8;BitCnt++)
 136   1        {
 137   2          //要传送的数据长度为8位
 138   2          if((c<<BitCnt)&0x80)
 139   2            SDA=1;     //判断发送位
 140   2          else  
 141   2            SDA=0;                
 142   2          _Nop();
 143   2          SCL=1;      //置时钟线为高，通知被控器开始接收数据位
 144   2          _Nop(); 
 145   2          _Nop();     //保证时钟高电平周期大于4μs
 146   2          _Nop();
 147   2          _Nop();
 148   2          _Nop();         
 149   2          SCL=0; 
 150   2        }
 151   1        _Nop();
 152   1        _Nop();
 153   1        SDA=1;        //8位发送完后释放数据线，准备接收应答位
 154   1        _Nop();
 155   1        _Nop();   
 156   1        SCL=1;
 157   1        _Nop();
 158   1        _Nop();
 159   1        _Nop();
 160   1        if(SDA==1)
 161   1          ack=0;     
 162   1        else 
 163   1          ack=1;      //判断是否接收到应答信号
 164   1        SCL=0;
 165   1        _Nop();
 166   1        _Nop();
 167   1      }
 168          //***************************************************************/
 169          //IIC字节数据接收函数RcvByte(void)，无形参,有返回值retc
 170          //***************************************************************/
 171          u8  RcvByte(void)
 172          {
 173   1        u8 retc;
 174   1        u8 BitCnt;
 175   1        retc=0; 
 176   1        SDA=1;       //置数据线为输入方式
 177   1        for(BitCnt=0;BitCnt<8;BitCnt++)
 178   1        {
 179   2          _Nop();           
C51 COMPILER V9.52.0.0   MAIN                                                              12/20/2019 16:20:47 PAGE 4   

 180   2          SCL=0;           //置时钟线为低，准备接收数据位
 181   2          _Nop();
 182   2          _Nop();         //时钟低电平周期大于4.7μs
 183   2          _Nop();
 184   2          _Nop();
 185   2          _Nop();
 186   2          SCL=1;          //置时钟线为高使数据线上数据有效
 187   2          _Nop();
 188   2          _Nop();
 189   2          retc=retc<<1;
 190   2          if(SDA==1)
 191   2            retc=retc+1; //读数据位,接收的数据位放入retc中
 192   2          _Nop();
 193   2          _Nop(); 
 194   2        }
 195   1        SCL=0;    
 196   1        _Nop();
 197   1        _Nop();
 198   1        return(retc);
 199   1      }
 200          //***************************************************************/
 201          //IIC应答子函数Ack_I2c(bit a)，有形参a,无返回值
 202          //***************************************************************/
 203          void Ack_I2c(bit a)
 204          {
 205   1        if(a==0)
 206   1          SDA=0;     //在此发出应答或非应答信号 
 207   1        else 
 208   1          SDA=1;
 209   1        _Nop();
 210   1        _Nop();
 211   1        _Nop();      
 212   1        SCL=1;
 213   1        _Nop();
 214   1        _Nop();     //时钟低电平周期大于4μs
 215   1        _Nop();
 216   1        _Nop();
 217   1        _Nop();  
 218   1        SCL=0;     //清时钟线，钳住I2C总线以便继续接收*/
 219   1        _Nop();
 220   1        _Nop();    
 221   1      } 
 222          //***************************************************************/
 223          //向无子地址器件发送字节数据函数 ISendByte(u8 sla,u8 c)
 224          //有形参sla:地址；c：发送数据；无返回值
 225          //***************************************************************/
 226          bit ISendByte(u8 sla,u8 c)
 227          {
 228   1        Start_I2c();         //启动总线
 229   1        SendByte(sla);       //发送器件地址
 230   1        if(ack==0)
 231   1          return(0);
 232   1        SendByte(c);         //发送数据
 233   1        if(ack==0)
 234   1          return(0);
 235   1        Stop_I2c();          //结束总线 
 236   1        return(1);
 237   1      } 
 238          //***************************************************************/
 239          //向有子地址器件发送多字节数据函数ISendStr(u8 sla,u8 suba,u8 *s,u8 no)
 240          //有形参sla:地址；suba：子地址；*s：数据数组；no：字节个数；有返回值1
 241          //***************************************************************/
C51 COMPILER V9.52.0.0   MAIN                                                              12/20/2019 16:20:47 PAGE 5   

 242          bit ISendStr(u8 sla,u8 suba,u8 *s,u8 no)
 243          {
 244   1        u8 i;
 245   1        
 246   1        Start_I2c();          //启动总线
 247   1      
 248   1        SendByte(sla);       //发送器件地址
 249   1        if(ack==0)
 250   1          return(0);
 251   1      
 252   1        SendByte(suba);      //发送器件子地址
 253   1        if(ack==0)
 254   1          return(0);
 255   1        
 256   1        for(i=0;i<no;i++)
 257   1        {   
 258   2          SendByte(*s);       //发送数据
 259   2          if(ack==0)return(0);
 260   2          s++;
 261   2        }
 262   1         
 263   1        Stop_I2c();          //结束总线
 264   1         
 265   1        return(1);
 266   1      } 
 267          //***************************************************************/
 268          //向无子地址器件读字节数据函数IRcvByte(u8 sla,u8 *c)
 269          //有形参sla:地址；suba：发送数据；*c：；有返回值1
 270          //***************************************************************/
 271          bit IRcvByte(u8 sla,u8 *c)
 272          {
 273   1        Start_I2c();        //启动总线
 274   1      
 275   1        SendByte(sla+1);    //发送器件地址
 276   1        if(ack==0)
 277   1          return(0);
 278   1      
 279   1        *c=RcvByte();       //读取数据
 280   1        Ack_I2c(1);         //发送非就答位
 281   1        Stop_I2c();         //结束总线
 282   1        return(1);
 283   1      } 
 284          //***************************************************************/
 285          //向有子地址器件接收多字节数据函数IRcvStr(u8 sla,u8 suba,u8 *s,u8 no)
 286          //有形参sla:地址；suba：子地址；*s：数据数组；no：字节个数；有返回值1
 287          //***************************************************************/
 288          bit IRcvStr(u8 sla,u8 suba,u8 *s,u8 no)
 289          {
 290   1        u8 i;
 291   1        
 292   1        Start_I2c();           //启动总线
 293   1        SendByte(sla);         //发送器件地址
 294   1        if(ack==0)
 295   1          return(0);
 296   1        SendByte(suba);        //发送器件子地址
 297   1        if(ack==0)
 298   1          return(0);  
 299   1        Start_I2c();
 300   1        SendByte(sla+1);
 301   1        if(ack==0)
 302   1          return(0);
 303   1        for(i=0;i<no-1;i++)
C51 COMPILER V9.52.0.0   MAIN                                                              12/20/2019 16:20:47 PAGE 6   

 304   1        {   
 305   2          *s=RcvByte();       //发送数据
 306   2          Ack_I2c(0);         //发送就答位 
 307   2          s++;
 308   2        } 
 309   1        *s=RcvByte();
 310   1        Ack_I2c(1);          //发送非应位
 311   1        Stop_I2c();          //结束总线 
 312   1        return(1);
 313   1      }
 314          //***************************************************************/
 315          //毫秒延迟函数Delay_Ms(u16 ms)
 316          //有形参ms:毫秒参数；无返回值
 317          //***************************************************************/
 318          void Delay_Ms(u16 ms)
 319          {
 320   1        unsigned int us;
 321   1        for(;ms>0;ms--)
 322   1          for(us=200;us>0;us--);
 323   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    758    ----
   CONSTANT SIZE    =      4    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
